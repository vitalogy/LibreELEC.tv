From b0bc68d9bfb8d33badd3c0f2f583934219bff120 Mon Sep 17 00:00:00 2001
From: Jamie Coldhill <wrxtasy@amnet.net.au>
Date: Mon, 19 Sep 2016 19:15:16 +0800
Subject: [PATCH] 
 Revert.all.Odroid.Specific.Sound.Mods.for.HiFi.Shield.and.usb_dac

---
 arch/arm64/boot/dts/meson64_odroidc2.dts       | 143 ++++++------
 arch/arm64/configs/odroidc2_defconfig          |  12 +-
 drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c |   2 +-
 include/sound/pcm.h                            |   5 -
 sound/core/pcm_native.c                        |   3 +-
 sound/soc/aml/m8/Kconfig                       |   9 -
 sound/soc/aml/m8/Makefile                      |   6 -
 sound/soc/aml/m8/aml_audio_hw.c                |  13 +-
 sound/soc/aml/m8/aml_audio_hw.h                |   2 +-
 sound/soc/aml/m8/aml_i2s.c                     |  83 +++----
 sound/soc/aml/m8/aml_i2s_dai.c                 |  55 ++---
 sound/soc/aml/m8/aml_m8.c                      |   2 +
 sound/soc/aml/m8/aml_spdif_codec.c             |   2 +-
 sound/soc/aml/m8/aml_spdif_dai.c               | 110 +++++++---
 sound/soc/aml/m8/aml_spdif_dai.h               |   4 +-
 sound/soc/aml/m8/odroid_dac.c                  | 292 -------------------------
 sound/soc/aml/m8/odroid_hdmi.c                 | 262 ----------------------
 sound/soc/aml/m8/odroid_hdmi.h                 |  31 ---
 sound/soc/codecs/Kconfig                       |   4 -
 sound/soc/codecs/Makefile                      |   2 -
 sound/soc/codecs/pcm5102.c                     | 161 --------------
 21 files changed, 222 insertions(+), 981 deletions(-)
 mode change 100755 => 100644 arch/arm64/boot/dts/meson64_odroidc2.dts
 delete mode 100644 sound/soc/aml/m8/odroid_dac.c
 delete mode 100644 sound/soc/aml/m8/odroid_hdmi.c
 delete mode 100644 sound/soc/aml/m8/odroid_hdmi.h
 delete mode 100644 sound/soc/codecs/pcm5102.c

diff --git a/arch/arm64/boot/dts/meson64_odroidc2.dts b/arch/arm64/boot/dts/meson64_odroidc2.dts
old mode 100755
new mode 100644
index 5f64ee3..e95be6a
--- a/arch/arm64/boot/dts/meson64_odroidc2.dts
+++ b/arch/arm64/boot/dts/meson64_odroidc2.dts
@@ -529,21 +529,24 @@
                         "usb0_to_ddr";
 	};
 
+	/* AUDIO MESON8 DEVICES */
 	i2s_dai: I2S {
-                compatible = "amlogic, aml-i2s-dai";
-                #sound-dai-cells = <0>;
-                resets = <&clock GCLK_IDX_AIU_AI_TOP_GLUE
-                        &clock GCLK_IDX_AUD_BUF_ABD
-                        &clock GCLK_IDX_AIU_I2S_OUT
-                        &clock GCLK_IDX_AIU_AMCLK_MEASURE
-                        &clock GCLK_IDX_AIU_AIFIFO2
-                        &clock GCLK_IDX_AIU_AUD_MIXER
-                        &clock GCLK_IDX_AIU_MIXER_REG
-                        &clock GCLK_IDX_AIU_ADC
-                        &clock GCLK_IDX_AIU_TOP_LEVEL
-                        &clock GCLK_IDX_AIU_AOCLK
-                        &clock GCLK_IDX_AUD_IN>;
-                reset-names = "top_glue",
+		#sound-dai-cells = <0>;
+		resets = <
+			&clock GCLK_IDX_AIU_AI_TOP_GLUE
+			&clock GCLK_IDX_AUD_BUF_ABD
+			&clock GCLK_IDX_AIU_I2S_OUT
+			&clock GCLK_IDX_AIU_AMCLK_MEASURE
+			&clock GCLK_IDX_AIU_AIFIFO2
+			&clock GCLK_IDX_AIU_AUD_MIXER
+			&clock GCLK_IDX_AIU_MIXER_REG
+			&clock GCLK_IDX_AIU_ADC
+			&clock GCLK_IDX_AIU_TOP_LEVEL
+			&clock GCLK_IDX_AIU_AOCLK
+			&clock GCLK_IDX_AUD_IN
+		>;
+		reset-names =
+			"top_glue",
 			"aud_buf",
 			"i2s_out",
 			"amclk_measure",
@@ -556,51 +559,46 @@
 			"aud_in";
 		clocks = <&clock CLK_MPLL0>,
 			<&clock CLK_AMCLK>;
-                clock-names = "mpll0",
-                        "mclk";
-	};
-
-	i2s_plat: i2s_platform {
-		compatible = "amlogic, aml-i2s";
+		clock-names = "mpll0", "mclk";
+		compatible = "amlogic, aml-i2s-dai";
 	};
-
 	spdif_dai: SPDIF {
-		compatible = "amlogic, aml-spdif-dai";
-		#sound-dai-cells = <0>;
-                resets = <&clock GCLK_IDX_AIU_IEC958
-                        &clock GCLK_IDX_AIU_ICE958_AMCLK>;
-                reset-names = "iec958",
-                        "iec958_amclk";
-                clocks = <&clock CLK_MPLL1>,
-                       <&clock CLK_I958>,
-                       <&clock CLK_AMCLK>,
-                       <&clock CLK_SPDIF>;
-                clock-names = "mpll1",
-                        "i958",
-                        "mclk",
-                        "spdif";
-	};
-
-	spdif_codec: spdif_codec{
 		#sound-dai-cells = <0>;
-		compatible = "amlogic, aml-spdif-codec";
-		pinctrl-names = "aml_audio_spdif";
-		pinctrl-0 = <&audio_spdif_pins>;
+		compatible = "amlogic, aml-spdif-dai";
+		resets = <
+			&clock GCLK_IDX_AIU_IEC958
+			&clock GCLK_IDX_AIU_ICE958_AMCLK
+		>;
+		reset-names =
+			"iec958",
+			"iec958_amclk";
+		clocks = <&clock CLK_MPLL1>,
+			<&clock CLK_I958>,
+			<&clock CLK_AMCLK>,
+			<&clock CLK_SPDIF>;
+		clock-names = "mpll1", "i958", "mclk", "spdif";
 	};
-
 	pcm_dai: PCM {
 		#sound-dai-cells = <0>;
 		compatible = "amlogic, aml-pcm-dai";
 	};
-
+	i2s_plat: i2s_platform {
+		compatible = "amlogic, aml-i2s";
+	};
 	pcm_plat: pcm_platform {
 		compatible = "amlogic, aml-pcm";
 	};
-
+	spdif_codec: spdif_codec{
+		#sound-dai-cells = <0>;
+		compatible = "amlogic, aml-spdif-codec";
+		pinctrl-names = "aml_audio_spdif";
+		pinctrl-0 = <&audio_spdif_pins>;
+	};
 	pcm_codec: pcm_codec{
 		#sound-dai-cells = <0>;
 		compatible = "amlogic, pcm2BT-codec";
 	};
+	/* endof AUDIO MESON8 DEVICES */
 
 	/* AUDIO board specific */
 	dummy_codec:dummy{
@@ -608,43 +606,40 @@
 		compatible = "amlogic, aml_dummy_codec";
 		status = "okay";
 	};
-
-	pcm5102_codec:pcm5102{
-		#sound-dai-cells = <0>;
-		compatible = "hardkernel, pcm5102";
-		status = "okay";
-	};
-
-	odroid_hdmi {
-		compatible = "sound_card, odroid_hdmi";
-		status = "okay";
-		aml-sound-card,format = "i2s";
-		aml_sound_card,name = "ODROID-HDMI";
-		cpu_list = <&i2sdai0>;
-		codec_list = <&dit0>;
-		plat_list = <&i2s_plat>;
-		i2sdai0: i2sdai0 {
-			sound-dai = <&i2s_dai>;
-		};
-		dit0: dit0 {
-			sound-dai = <&spdif_codec>;
-		};
-	};
-	odroid_dac {
-		compatible = "sound_card, odroid_dac";
+	aml_m8_snd {
+		compatible = "aml, aml_snd_m8";
 		status = "okay";
 		aml-sound-card,format = "i2s";
-		aml_sound_card,name = "ODROID-DAC";
-		pinctrl-names = "aml_snd_i2s";
+		aml_sound_card,name = "AML-M8AUDIO";
+		aml,audio-routing =
+				"Ext Spk","LOUTL",
+				"Ext Spk","LOUTR";
+
+		mute_gpio-gpios = <&gpio GPIOH_3 0>;
+		hp_disable;
+		hp_paraments = <800 300 0 5 1>;
+		pinctrl-names = "aml_snd_m8";
 		pinctrl-0 = <&audio_pins>;
-		cpu_list = <&cpudai0>;
-		codec_list = <&codec0>;
-		plat_list = <&i2s_plat>;
+		cpu_list = <&cpudai0 &cpudai1 &cpudai2>;
+		codec_list = <&codec0 &codec1 &codec2>;
+		plat_list = <&i2s_plat &i2s_plat &pcm_plat>;
 		cpudai0: cpudai0 {
 			sound-dai = <&i2s_dai>;
 		};
+		cpudai1: cpudai1 {
+			sound-dai = <&spdif_dai>;
+		};
+		cpudai2: cpudai2 {
+			sound-dai = <&pcm_dai>;
+		};
 		codec0: codec0 {
-			sound-dai = <&pcm5102_codec>;
+			sound-dai = <&dummy_codec>;
+		};
+		codec1: codec1 {
+			sound-dai = <&spdif_codec>;
+		};
+		codec2: codec2 {
+			sound-dai = <&pcm_codec>;
 		};
 	};
 	/* END OF AUDIO board specific */
diff --git a/arch/arm64/configs/odroidc2_defconfig b/arch/arm64/configs/odroidc2_defconfig
index 079f956..08de48b 100644
--- a/arch/arm64/configs/odroidc2_defconfig
+++ b/arch/arm64/configs/odroidc2_defconfig
@@ -3237,8 +3237,8 @@ CONFIG_SOUND_OSS_CORE_PRECLAIM=y
 CONFIG_SND=y
 CONFIG_SND_TIMER=y
 CONFIG_SND_PCM=y
-CONFIG_SND_HWDEP=m
-CONFIG_SND_RAWMIDI=m
+CONFIG_SND_HWDEP=y
+CONFIG_SND_RAWMIDI=y
 CONFIG_SND_COMPRESS_OFFLOAD=y
 CONFIG_SND_JACK=y
 CONFIG_SND_SEQUENCER=m
@@ -3272,7 +3272,7 @@ CONFIG_SND_DRIVERS=y
 # CONFIG_SND_AC97_POWER_SAVE is not set
 CONFIG_SND_SPI=y
 CONFIG_SND_USB=y
-CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_AUDIO=y
 CONFIG_SND_USB_UA101=m
 CONFIG_SND_USB_CAIAQ=m
 CONFIG_SND_USB_CAIAQ_INPUT=y
@@ -3282,12 +3282,10 @@ CONFIG_SND_SOC=y
 # CONFIG_SND_ATMEL_SOC is not set
 # CONFIG_SND_DESIGNWARE_I2S is not set
 CONFIG_SND_AML_M8_SOC=y
-# CONFIG_SND_AML_M8 is not set
-CONFIG_SND_ODROID_HDMI=y
-CONFIG_SND_ODROID_DAC=m
 # CONFIG_SND_AML_G9TV is not set
 CONFIG_SND_SOC_I2C_AND_SPI=y
-CONFIG_SND_SOC_PCM5102=m
+CONFIG_SND_SOC_DUMMY_CODEC=y
+CONFIG_SND_SOC_PCM2BT=y
 # CONFIG_SND_SIMPLE_CARD is not set
 # CONFIG_SOUND_PRIME is not set
 CONFIG_AC97_BUS=m
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
index f53f0e4..e6d04dd 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
@@ -1664,7 +1664,7 @@ static int hdmi_task_handle(void *data)
 	INIT_WORK(&hdmitx_device->work_internal_intr,
 		hdmitx_internal_intr_handler);
 
-	/*hdmitx_device->tx_aud_cfg = 1;*/ /* default audio configure is on */
+	hdmitx_device->tx_aud_cfg = 1; /* default audio configure is on */
 	if (init_flag & INIT_FLAG_POWERDOWN) {
 		/* power down */
 		hdmitx_device->HWOp.SetDispMode(hdmitx_device, NULL);
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 1f1cdef..f589388 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -126,8 +126,6 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_RATE_96000		(1<<10)		/* 96000Hz */
 #define SNDRV_PCM_RATE_176400		(1<<11)		/* 176400Hz */
 #define SNDRV_PCM_RATE_192000		(1<<12)		/* 192000Hz */
-#define SNDRV_PCM_RATE_352800		(1<<13)		/* 352800Hz */
-#define SNDRV_PCM_RATE_384000		(1<<14)		/* 384000Hz */
 
 #define SNDRV_PCM_RATE_CONTINUOUS	(1<<30)		/* continuous range */
 #define SNDRV_PCM_RATE_KNOT		(1<<31)		/* supports more non-continuos rates */
@@ -140,9 +138,6 @@ struct snd_pcm_ops {
 					 SNDRV_PCM_RATE_88200|SNDRV_PCM_RATE_96000)
 #define SNDRV_PCM_RATE_8000_192000	(SNDRV_PCM_RATE_8000_96000|SNDRV_PCM_RATE_176400|\
 					 SNDRV_PCM_RATE_192000)
-#define	SNDRV_PCM_RATE_8000_384000	(SNDRV_PCM_RATE_8000_192000|\
-					 SNDRV_PCM_RATE_352800|\
-					 SNDRV_PCM_RATE_384000)
 
 #define _SNDRV_PCM_FMTBIT(fmt)		(1ULL << (__force int)SNDRV_PCM_FORMAT_##fmt)
 #define SNDRV_PCM_FMTBIT_S8		_SNDRV_PCM_FMTBIT(S8)
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index b3406f3..8238722 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -1786,8 +1786,7 @@ static int snd_pcm_hw_rule_sample_bits(struct snd_pcm_hw_params *params,
 #endif
 
 static unsigned int rates[] = { 5512, 8000, 11025, 16000, 22050, 32000, 44100,
-				48000, 64000, 88200, 96000, 176400, 192000,
-				352800, 384000 };
+				48000, 64000, 88200, 96000, 176400, 192000 };
 
 const struct snd_pcm_hw_constraint_list snd_pcm_known_rates = {
 	.count = ARRAY_SIZE(rates),
diff --git a/sound/soc/aml/m8/Kconfig b/sound/soc/aml/m8/Kconfig
index 4adfb7d..d182291 100644
--- a/sound/soc/aml/m8/Kconfig
+++ b/sound/soc/aml/m8/Kconfig
@@ -11,15 +11,6 @@ menuconfig SND_AML_M8
 #	select SND_SOC_AMLPMU4 if AML1220
 #	select SND_SOC_ES8323
 
-menuconfig SND_ODROID_HDMI
-	tristate "ODROID-SND-HDMI card"
-	depends on SND_AML_M8_SOC
-
-menuconfig SND_ODROID_DAC
-	tristate "ODROID-SND-DAC card"
-	depends on SND_AML_M8_SOC
-	select SND_SOC_PCM5102
-
 menuconfig SND_AML_G9TV
 	tristate "AML-SND-G9TV Board"
 	depends on SND_AML_M8_SOC && SWITCH
diff --git a/sound/soc/aml/m8/Makefile b/sound/soc/aml/m8/Makefile
index 2ed8755..e6bfba1 100644
--- a/sound/soc/aml/m8/Makefile
+++ b/sound/soc/aml/m8/Makefile
@@ -24,12 +24,6 @@ obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-spdif-codec.o
 snd-soc-aml-m8-objs := aml_m8.o
 obj-$(CONFIG_SND_AML_M8) += snd-soc-aml-m8.o
 
-#ODROID Machine support
-snd-soc-odroid-hdmi-objs := odroid_hdmi.o
-snd-soc-odroid-dac-objs := odroid_dac.o
-obj-$(CONFIG_SND_ODROID_HDMI) += snd-soc-odroid-hdmi.o
-obj-$(CONFIG_SND_ODROID_DAC) += snd-soc-odroid-dac.o
-
 #AML G9TV Machine support
 snd-soc-aml-g9tv-objs := aml_g9tv.o
 obj-$(CONFIG_SND_AML_G9TV) += snd-soc-aml-g9tv.o
diff --git a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
index 09054a2..33268a2 100644
--- a/sound/soc/aml/m8/aml_audio_hw.c
+++ b/sound/soc/aml/m8/aml_audio_hw.c
@@ -576,21 +576,16 @@ void audio_util_set_dac_i2s_format(unsigned format)
 	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x0001);
 }
 
-/* set sclk and lrclk, mclk = 256fs. if srate > 192000, than mclk = 128fs.*/
-void audio_set_i2s_clk_div(int srate)
+/* set sclk and lrclk, mclk = 256fs. */
+void audio_set_i2s_clk_div(void)
 {
 	/* aiclk source */
 	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 10, 1 << 10);
 	/* Set mclk over sclk ratio */
 	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x3f << 8, (4 - 1) << 8);
 	/* set dac/adc lrclk ratio over sclk----64fs */
-	if (srate > 192000) {
-		aml_cbus_update_bits(AIU_CODEC_DAC_LRCLK_CTRL, 0xfff, (32 - 1));
-		aml_cbus_update_bits(AIU_CODEC_ADC_LRCLK_CTRL, 0xfff, (32 - 1));
-	} else {
-		aml_cbus_update_bits(AIU_CODEC_DAC_LRCLK_CTRL, 0xfff, (64 - 1));
-		aml_cbus_update_bits(AIU_CODEC_ADC_LRCLK_CTRL, 0xfff, (64 - 1));
-	}
+        aml_cbus_update_bits(AIU_CODEC_DAC_LRCLK_CTRL, 0xfff, (64 - 1));
+	aml_cbus_update_bits(AIU_CODEC_ADC_LRCLK_CTRL, 0xfff, (64 - 1));
 	/* Enable sclk */
 	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 14, 1 << 14);
 }
diff --git a/sound/soc/aml/m8/aml_audio_hw.h b/sound/soc/aml/m8/aml_audio_hw.h
index d394150..90aee90 100644
--- a/sound/soc/aml/m8/aml_audio_hw.h
+++ b/sound/soc/aml/m8/aml_audio_hw.h
@@ -126,7 +126,7 @@ unsigned int audio_in_i2s_rd_ptr(void);
 unsigned int audio_in_i2s_wr_ptr(void);
 unsigned int audio_in_spdif_wr_ptr(void);
 void audio_set_i2s_mode(u32 mode);
-void audio_set_i2s_clk_div(int srate);
+void audio_set_i2s_clk_div(void);
 void audio_set_spdif_clk_div(void);
 void audio_enable_ouput(int flag);
 unsigned int read_i2s_rd_ptr(void);
diff --git a/sound/soc/aml/m8/aml_i2s.c b/sound/soc/aml/m8/aml_i2s.c
index 95ca2e5..64bed25 100644
--- a/sound/soc/aml/m8/aml_i2s.c
+++ b/sound/soc/aml/m8/aml_i2s.c
@@ -93,17 +93,17 @@ static const struct snd_pcm_hardware aml_i2s_hardware = {
 	    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
 	    SNDRV_PCM_FMTBIT_S32_LE,
 
-	.period_bytes_min = 32,
+	.period_bytes_min = 64,
 	.period_bytes_max = 32 * 1024 * 2,
 	.periods_min = 2,
-	.periods_max = 256,
-	.buffer_bytes_max = 32 * 1024 * 2,
+	.periods_max = 1024,
+	.buffer_bytes_max = 128 * 1024 * 2 * 2,
 
 	.rate_min = 8000,
-	.rate_max = 384000,
-	.channels_min = 1,
+	.rate_max = 48000,
+	.channels_min = 2,
 	.channels_max = 8,
-	.fifo_size = 32,
+	.fifo_size = 0,
 };
 
 static const struct snd_pcm_hardware aml_i2s_capture = {
@@ -116,7 +116,7 @@ static const struct snd_pcm_hardware aml_i2s_capture = {
 	.period_bytes_min = 64,
 	.period_bytes_max = 32 * 1024,
 	.periods_min = 2,
-	.periods_max = 256,
+	.periods_max = 1024,
 	.buffer_bytes_max = 64 * 1024,
 
 	.rate_min = 8000,
@@ -582,23 +582,6 @@ static int aml_i2s_close(struct snd_pcm_substream *substream)
 /* extern void audio_hw_958_enable(unsigned flag); */
 /* extern int kernel_android_50; */
 
-static char *get_hw_buf_ptr(struct snd_pcm_runtime *runtime,
-				snd_pcm_uframes_t cur_pos, int align)
-{
-	unsigned int tot_bytes_per_channel =
-		frames_to_bytes(runtime, cur_pos) / runtime->channels;
-	unsigned int bytes_aligned_per_channel =
-		frames_to_bytes(runtime, align / runtime->channels);
-	unsigned int hw_base_off =
-		tot_bytes_per_channel / bytes_aligned_per_channel;
-	unsigned int block_off =
-		tot_bytes_per_channel % bytes_aligned_per_channel;
-
-	return runtime->dma_area +
-		(frames_to_bytes(runtime, align) * hw_base_off) +
-		block_off;
-}
-
 static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 				 snd_pcm_uframes_t pos,
 				 void __user *buf, snd_pcm_uframes_t count,
@@ -629,32 +612,48 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 		return -EFAULT;
 	if (access_ok(VERIFY_READ, buf, frames_to_bytes(runtime, count))) {
 		if (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
+
 			int16_t *tfrom, *to, *left, *right;
 			tfrom = (int16_t *) ubuf;
+			to = (int16_t *) hwbuf;
+
+			left = to;
+			right = to + 16;
+			if (pos % align) {
+				pr_info("audio data unligned: pos=%d, n=%d, align=%d\n",
+				     (int)pos, n, align);
+			}
 
-			for (j = 0; j < count; j++) {
-				to = (int16_t *) get_hw_buf_ptr(runtime,
-								pos + j,
-								align);
-				left = to;
-				right = to + align;
-				*left = (*tfrom++);
-				*right = (*tfrom++);
+			for (j = 0; j < n; j += 64) {
+				for (i = 0; i < 16; i++) {
+					*left++ = (*tfrom++);
+					*right++ = (*tfrom++);
+				}
+				left += 16;
+				right += 16;
 			}
-		} else if (runtime->format == SNDRV_PCM_FORMAT_S24_LE) {
+		} else if (runtime->format == SNDRV_PCM_FORMAT_S24_LE
+			   && I2S_MODE == AIU_I2S_MODE_PCM24) {
 			int32_t *tfrom, *to, *left, *right;
 			tfrom = (int32_t *) ubuf;
+			to = (int32_t *) hwbuf;
 
-			for (j = 0; j < count; j++) {
-				to = (int32_t *) get_hw_buf_ptr(runtime,
-								pos + j,
-								align);
-				left = to;
-				right = to + align;
+			left = to;
+			right = to + 8;
 
-				*left = (*tfrom++);
-				*right = (*tfrom++);
+			if (pos % align) {
+				pr_info("audio data unaligned: pos=%d, n=%d, align=%d\n",
+				     (int)pos, n, align);
 			}
+			for (j = 0; j < n; j += 64) {
+				for (i = 0; i < 8; i++) {
+					*left++ = (*tfrom++);
+					*right++ = (*tfrom++);
+				}
+				left += 8;
+				right += 8;
+			}
+
 		} else if (runtime->format == SNDRV_PCM_FORMAT_S32_LE) {
 			int32_t *tfrom, *to, *left, *right;
 			tfrom = (int32_t *) ubuf;
@@ -779,6 +778,8 @@ static int aml_i2s_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 				left += 8;
 				right += 8;
 			}
+			/* clean hw buffer */
+			memset(hwbuf, 0, n * 2);
 		}
 	}
 	res = copy_to_user(buf, ubuf, n);
diff --git a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
index 7f86c32..5dfbaf1 100644
--- a/sound/soc/aml/m8/aml_i2s_dai.c
+++ b/sound/soc/aml/m8/aml_i2s_dai.c
@@ -43,7 +43,6 @@
 #include "aml_i2s.h"
 #include "aml_audio_hw.h"
 #include <linux/amlogic/sound/aout_notify.h>
-#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
 #include "aml_spdif_dai.h"
 
 struct aml_dai_info dai_info[3] = { {0} };
@@ -64,7 +63,6 @@ static int i2s_pos_sync;
 /* extern int set_i2s_iec958_samesource(int enable); */
 #define DEFAULT_SAMPLERATE 48000
 #define DEFAULT_MCLK_RATIO_SR 256
-#define MCLK_RATIO_128FS_SR 128
 static int i2sbuf[32 + 16];
 static void aml_i2s_play(void)
 {
@@ -138,6 +136,8 @@ static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
 				 struct snd_soc_dai *dai)
 {
+	if (IEC958_mode_codec == 0)
+		aml_spdif_play();
 	return;
 }
 
@@ -164,7 +164,7 @@ static int aml_i2s_set_amclk(struct aml_i2s *i2s, unsigned long rate)
 		return ret;
 	}
 
-	audio_set_i2s_clk_div(i2s->old_samplerate);
+	audio_set_i2s_clk_div();
 
 	return 0;
 }
@@ -219,19 +219,8 @@ static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 			       struct snd_soc_dai *dai)
 {
 	struct snd_pcm_runtime *rtd = substream->runtime;
-	struct snd_soc_pcm_runtime *prtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = prtd->codec_dai;
 	int *ppp = NULL;
-	bool hdmi_out = false;
-
 	ALSA_TRACE();
-
-	if (!strncmp(codec_dai->name, "dit-hifi", strlen("dit-hifi"))) {
-		hdmi_out = true;
-	} else {
-		hdmi_out = false;
-	}
-
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
@@ -240,16 +229,9 @@ static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 			pr_info("aiu i2s playback enable\n");
 			audio_out_i2s_enable(1);
-			if (hdmi_out) {
-				aml_audio_i2s_mute();
-				hdmitx_audio_mute_op(1);
-				if (IEC958_mode_codec == 0) {
-					pr_info("audio_hw_958_enable 1\n");
-					audio_hw_958_enable(1);
-				}
-			} else {
-				aml_audio_i2s_unmute();
-				hdmitx_audio_mute_op(0);
+			if (IEC958_mode_codec == 0) {
+				pr_info("audio_hw_958_enable 1\n");
+				audio_hw_958_enable(1);
 			}
 		} else {
 			audio_in_i2s_enable(1);
@@ -289,10 +271,7 @@ static int aml_dai_i2s_hw_params(struct snd_pcm_substream *substream,
 	srate = params_rate(params);
 	if (i2s->old_samplerate != srate) {
 		i2s->old_samplerate = srate;
-		if (srate > 192000)
-			mclk_rate = srate * MCLK_RATIO_128FS_SR;
-		else
-			mclk_rate = srate * DEFAULT_MCLK_RATIO_SR;
+		mclk_rate = srate * DEFAULT_MCLK_RATIO_SR;
 		aml_i2s_set_amclk(i2s, mclk_rate);
 	}
 
@@ -325,25 +304,27 @@ static int aml_dai_set_i2s_sysclk(struct snd_soc_dai *dai,
 	return 0;
 }
 
-#ifdef CONFIG_PM
 static int aml_dai_i2s_suspend(struct snd_soc_dai *dai)
 {
-	ALSA_TRACE();
+	struct aml_i2s *i2s = dev_get_drvdata(dai->dev);
+
+	if (i2s && i2s->clk_mclk)
+		clk_disable_unprepare(i2s->clk_mclk);
+
 	return 0;
 }
 
 static int aml_dai_i2s_resume(struct snd_soc_dai *dai)
 {
-	ALSA_TRACE();
+	struct aml_i2s *i2s = dev_get_drvdata(dai->dev);
+
+	if (i2s && i2s->clk_mclk)
+		clk_prepare_enable(i2s->clk_mclk);
+
 	return 0;
 }
 
-#else				/* CONFIG_PM */
-#define aml_dai_i2s_suspend	NULL
-#define aml_dai_i2s_resume	NULL
-#endif				/* CONFIG_PM */
-
-#define AML_DAI_I2S_RATES		(SNDRV_PCM_RATE_8000_384000)
+#define AML_DAI_I2S_RATES		(SNDRV_PCM_RATE_8000_192000)
 #define AML_DAI_I2S_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
 		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
diff --git a/sound/soc/aml/m8/aml_m8.c b/sound/soc/aml/m8/aml_m8.c
index 7744375..2012bba 100644
--- a/sound/soc/aml/m8/aml_m8.c
+++ b/sound/soc/aml/m8/aml_m8.c
@@ -626,6 +626,7 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
 
 	snd_soc_card_set_drvdata(card, p_aml_audio);
 	card->dev = dev;
+	platform_set_drvdata(pdev, card);
 	ret = snd_soc_of_parse_card_name(card, "aml_sound_card,name");
 	if (ret < 0) {
 		dev_err(dev, "no specific snd_soc_card name\n");
@@ -678,6 +679,7 @@ static struct platform_driver aml_m8_audio_driver = {
 		   .name = DRV_NAME,
 		   .owner = THIS_MODULE,
 		   .of_match_table = amlogic_audio_of_match,
+		   .pm = &snd_soc_pm_ops,
 		   },
 	.probe = aml_m8_audio_probe,
 };
diff --git a/sound/soc/aml/m8/aml_spdif_codec.c b/sound/soc/aml/m8/aml_spdif_codec.c
index 73223b1..5ef287b 100644
--- a/sound/soc/aml/m8/aml_spdif_codec.c
+++ b/sound/soc/aml/m8/aml_spdif_codec.c
@@ -26,7 +26,7 @@
 
 #define DRV_NAME "spdif-dit"
 
-#define STUB_RATES	SNDRV_PCM_RATE_8000_384000
+#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
 #define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
 	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
diff --git a/sound/soc/aml/m8/aml_spdif_dai.c b/sound/soc/aml/m8/aml_spdif_dai.c
index f80c5e9..7b42d2d 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.c
+++ b/sound/soc/aml/m8/aml_spdif_dai.c
@@ -73,12 +73,15 @@ struct aml_spdif {
 	int old_samplerate;
 };
 struct aml_spdif *spdif_p;
-/*
+unsigned int clk81 = 0;
+EXPORT_SYMBOL(clk81);
+
 static int iec958buf[32 + 16];
-*/
+static int old_samplerate = -1;
+
 void aml_spdif_play(void)
 {
-#if 0
+#if 1
 	struct _aiu_958_raw_setting_t set;
 	struct _aiu_958_channel_status_t chstat;
 	struct snd_pcm_substream substream;
@@ -96,12 +99,28 @@ void aml_spdif_play(void)
 	set.chan_stat->chstat1_l = 0X200;
 	set.chan_stat->chstat1_r = 0X200;
 	audio_hw_958_enable(0);
-	if (last_iec_clock != AUDIO_CLK_FREQ_48) {
-		ALSA_PRINT("enterd %s,set_clock:%d,sample_rate=%d\n", __func__,
-			   last_iec_clock, AUDIO_CLK_FREQ_48);
-		last_iec_clock = AUDIO_CLK_FREQ_48;
-		audio_set_958_clk(AUDIO_CLK_FREQ_48, AUDIO_CLK_256FS);
+	if (old_samplerate != AUDIO_CLK_FREQ_48) {
+		pr_info("enterd %s,set_clock:%d,sample_rate=%d\n",
+		__func__, old_samplerate, AUDIO_CLK_FREQ_48);
+		old_samplerate = AUDIO_CLK_FREQ_48;
+		aml_set_spdif_clk(48000 * 512, 0);
+	}
+	/* Todo, div can be changed, for most case, div = 2 */
+	/* audio_set_spdif_clk_div(); */
+	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
+	if (IEC958_mode_codec == 4  || IEC958_mode_codec == 5 ||
+	IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
+		pr_info("set 4x audio clk for 958\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
+	} else if (0) {
+		pr_info("share the same clock\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
+	} else {
+		pr_info("set normal 512 fs /4 fs\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
 	}
+	/* enable 958 divider */
+	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
 	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
 	memset(iec958buf, 0, sizeof(iec958buf));
 	audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63), 128, 0);
@@ -237,7 +256,26 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 	       runtime->rate, sample_rate);
 	/* int srate; */
 	/* srate = params_rate(params); */
-	aml_set_spdif_clk(runtime->rate * 512, 0);
+	if (old_samplerate != sample_rate) {
+		old_samplerate = sample_rate;
+		aml_set_spdif_clk(runtime->rate * 512, 0);
+	}
+	/* Todo, div can be changed, for most case, div = 2 */
+	/* audio_set_spdif_clk_div(); */
+	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
+	if (IEC958_mode_codec == 4  || IEC958_mode_codec == 5 ||
+	IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
+		pr_info("set 4x audio clk for 958\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
+	} else if (0) {
+		pr_info("share the same clock\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
+	} else {
+		pr_info("set normal 512 fs /4 fs\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
+	}
+	/* enable 958 divider */
+	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
 	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
 	/*clear the same source function as new raw data output */
 	audio_i2s_958_same_source(0);
@@ -357,7 +395,12 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 		aml_write_cbus(AIU_958_CHSTAT_L1, 0x900);
 		aml_write_cbus(AIU_958_CHSTAT_R0, 0x1902);
 		aml_write_cbus(AIU_958_CHSTAT_R1, 0x900);
-		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_MAT_MLP, substream);
+		if (IEC958_mode_codec == 8)
+			aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD_MA,
+			substream);
+		else
+			aout_notifier_call_chain(AOUT_EVENT_RAWDATA_MAT_MLP,
+			substream);
 	} else {
 		aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM, substream);
 	}
@@ -508,22 +551,6 @@ int aml_set_spdif_clk(unsigned long rate, bool src_i2s)
 		}
 	}
 
-	/* Todo, div can be changed, for most case, div = 2 */
-	/* audio_set_spdif_clk_div(); */
-	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	if (IEC958_mode_codec == 4  || IEC958_mode_codec == 5 ||
-	IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
-		pr_info("set 4x audio clk for 958\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
-	} else if (src_i2s) {
-		pr_info("share the same clock\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
-	} else {
-		pr_info("set normal 512 fs /4 fs\n");
-		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
-	}
-	/* enable 958 divider */
-	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
 	return 0;
 }
 
@@ -540,24 +567,27 @@ static int aml_dai_spdif_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-#ifdef CONFIG_PM
 static int aml_dai_spdif_suspend(struct snd_soc_dai *cpu_dai)
 {
-	ALSA_TRACE();
+	struct aml_spdif *spdif_priv = dev_get_drvdata(cpu_dai->dev);
+
 	aml_spdif_play_stop();
+	if (spdif_priv && spdif_priv->clk_spdif)
+		clk_disable_unprepare(spdif_priv->clk_spdif);
+
 	return 0;
 }
 
 static int aml_dai_spdif_resume(struct snd_soc_dai *cpu_dai)
 {
-	ALSA_TRACE();
-	aml_spdif_play();
+	struct aml_spdif *spdif_priv = dev_get_drvdata(cpu_dai->dev);
+
+	/*aml_spdif_play();*/
+	if (spdif_priv && spdif_priv->clk_spdif)
+		clk_prepare_enable(spdif_priv->clk_spdif);
+
 	return 0;
 }
-#else
-#define aml_spdif_suspend NULL
-#define aml_spdif_resume NULL
-#endif
 
 static struct snd_soc_dai_ops spdif_dai_ops = {
 	.set_sysclk = aml_dai_spdif_set_sysclk,
@@ -660,6 +690,18 @@ static int aml_dai_spdif_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	ret = clk_set_parent(spdif_priv->clk_i958, spdif_priv->clk_mpl1);
+	if (ret) {
+		pr_err("Can't set i958 clk parent: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_set_parent(spdif_priv->clk_spdif, spdif_priv->clk_i958);
+	if (ret) {
+		pr_err("Can't set spdif clk parent: %d\n", ret);
+		return ret;
+	}
+
 	ret = clk_prepare_enable(spdif_priv->clk_spdif);
 	if (ret) {
 		pr_err("Can't enable spdif clock: %d\n", ret);
diff --git a/sound/soc/aml/m8/aml_spdif_dai.h b/sound/soc/aml/m8/aml_spdif_dai.h
index 8fe56ca..fd11637 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.h
+++ b/sound/soc/aml/m8/aml_spdif_dai.h
@@ -33,7 +33,7 @@
 #define AOUT_EVENT_RAWDATA_MAT_MLP              0xC
 #define AOUT_EVENT_RAWDATA_DST                  0xD
 #define AOUT_EVENT_RAWDATA_WMA_PRO              0xE
-
+#define AOUT_EVENT_RAWDATA_DTS_HD_MA (AOUT_EVENT_RAWDATA_DTS_HD|(1<<8))
 extern unsigned int IEC958_mode_codec;
 
 /*
@@ -47,5 +47,5 @@ extern unsigned int IEC958_mode_codec;
 */
 void aml_hw_iec958_init(struct snd_pcm_substream *substream);
 int aml_set_spdif_clk(unsigned long rate, bool src_i2s);
-
+void aml_spdif_play(void);
 #endif  /* _AML_SPDIF_DAI_H */
diff --git a/sound/soc/aml/m8/odroid_dac.c b/sound/soc/aml/m8/odroid_dac.c
deleted file mode 100644
index aaf8fbd..0000000
--- a/sound/soc/aml/m8/odroid_dac.c
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * sound/soc/aml/m8/aml_m8.c
- *
- * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
-*/
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-/* #include <sound/soc-dapm.h> */
-#include <sound/jack.h>
-#include <linux/switch.h>
-/* #include <linux/amlogic/saradc.h> */
-#include <linux/amlogic/iomap.h>
-
-/* #include "aml_i2s_dai.h" */
-#include "aml_i2s.h"
-#include "odroid_dac.h"
-#include "aml_audio_hw.h"
-#include <linux/amlogic/sound/audin_regs.h>
-#include <linux/of.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/of_gpio.h>
-#include <linux/io.h>
-#define DRV_NAME "odroid_dac_snd"
-/* extern struct device *spdif_dev; */
-
-static int aml_suspend_pre(struct snd_soc_card *card)
-{
-	pr_info(KERN_INFO "enter %s\n", __func__);
-	return 0;
-}
-
-static int aml_suspend_post(struct snd_soc_card *card)
-{
-	pr_info(KERN_INFO "enter %s\n", __func__);
-	/* if(ext_codec) */
-	/* i2s_gpio_set(card); */
-	return 0;
-}
-
-static int aml_resume_pre(struct snd_soc_card *card)
-{
-	pr_info(KERN_INFO "enter %s\n", __func__);
-
-	return 0;
-}
-
-static int aml_resume_post(struct snd_soc_card *card)
-{
-	pr_info(KERN_INFO "enter %s\n", __func__);
-	return 0;
-}
-
-static void aml_i2s_pinmux_init(struct snd_soc_card *card)
-{
-	struct odroid_audio_private_data *p_aml_audio;
-
-	p_aml_audio = snd_soc_card_get_drvdata(card);
-
-	p_aml_audio->pin_ctl =
-		devm_pinctrl_get_select(card->dev, "aml_snd_i2s");
-	if (IS_ERR(p_aml_audio->pin_ctl))
-		pr_info("%s,aml_i2s_pinmux_init error!\n", __func__);
-}
-
-static int aml_card_dai_parse_of(struct device *dev,
-				 struct snd_soc_dai_link *dai_link,
-				 int (*init)(struct snd_soc_pcm_runtime *rtd),
-				 struct device_node *cpu_node,
-				 struct device_node *codec_node,
-				 struct device_node *plat_node)
-{
-	int ret;
-
-	/* get cpu dai->name */
-	ret = snd_soc_of_get_dai_name(cpu_node, &dai_link->cpu_dai_name);
-	if (ret < 0)
-		goto parse_error;
-
-	/* get codec dai->name */
-	ret = snd_soc_of_get_dai_name(codec_node, &dai_link->codec_dai_name);
-	if (ret < 0)
-		goto parse_error;
-
-	dai_link->name = dai_link->stream_name = dai_link->cpu_dai_name;
-	dai_link->codec_of_node = of_parse_phandle(codec_node, "sound-dai", 0);
-	dai_link->platform_of_node = plat_node;
-	dai_link->init = init;
-
-	return 0;
-
- parse_error:
-	return ret;
-}
-
-static int aml_card_dais_parse_of(struct snd_soc_card *card)
-{
-	struct device_node *np = card->dev->of_node;
-	struct device_node *cpu_node, *codec_node, *plat_node;
-	struct device *dev = card->dev;
-	struct snd_soc_dai_link *dai_links;
-	int num_dai_links, cpu_num, codec_num, plat_num;
-	int i, ret;
-	int (*init)(struct snd_soc_pcm_runtime *rtd);
-
-	ret = of_count_phandle_with_args(np, "cpu_list", NULL);
-	if (ret < 0) {
-		dev_err(dev, "AML sound card no cpu_list errno: %d\n", ret);
-		goto err;
-	} else {
-		cpu_num = ret;
-	}
-	ret = of_count_phandle_with_args(np, "codec_list", NULL);
-	if (ret < 0) {
-		dev_err(dev, "AML sound card no codec_list errno: %d\n", ret);
-		goto err;
-	} else {
-		codec_num = ret;
-	}
-	ret = of_count_phandle_with_args(np, "plat_list", NULL);
-	if (ret < 0) {
-		dev_err(dev, "AML sound card no plat_list errno: %d\n", ret);
-		goto err;
-	} else {
-		plat_num = ret;
-	}
-	if ((cpu_num == codec_num) && (cpu_num == plat_num)) {
-		num_dai_links = cpu_num;
-	} else {
-		dev_err(dev,
-			"AML sound card cpu_dai num, codec_dai num, platform num don't match: %d\n",
-			ret);
-		ret = -EINVAL;
-		goto err;
-	}
-
-	dai_links =
-	    devm_kzalloc(dev, num_dai_links * sizeof(struct snd_soc_dai_link),
-			 GFP_KERNEL);
-	if (!dai_links) {
-		dev_err(dev, "Can't allocate snd_soc_dai_links\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-	card->dai_link = dai_links;
-	card->num_links = num_dai_links;
-	for (i = 0; i < num_dai_links; i++) {
-		init = NULL;
-		/* CPU sub-node */
-		cpu_node = of_parse_phandle(np, "cpu_list", i);
-		if (cpu_node < 0) {
-			dev_err(dev, "parse aml sound card cpu list error\n");
-			return -EINVAL;
-		}
-		/* CODEC sub-node */
-		codec_node = of_parse_phandle(np, "codec_list", i);
-		if (codec_node < 0) {
-			dev_err(dev, "parse aml sound card codec list error\n");
-			return ret;
-		}
-		/* Platform sub-node */
-		plat_node = of_parse_phandle(np, "plat_list", i);
-		if (plat_node < 0) {
-			dev_err(dev,
-				"parse aml sound card platform list error\n");
-			return ret;
-		}
-
-		ret =
-		    aml_card_dai_parse_of(dev, &dai_links[i], init, cpu_node,
-					  codec_node, plat_node);
-	}
-
- err:
-	return ret;
-}
-
-static int odroid_dac_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct snd_soc_card *card;
-	struct odroid_audio_private_data *p_aml_audio;
-	int ret;
-
-	p_aml_audio =
-	    devm_kzalloc(dev, sizeof(struct odroid_audio_private_data),
-			 GFP_KERNEL);
-	if (!p_aml_audio) {
-		dev_err(&pdev->dev, "Can't allocate odroid_audio_private_data\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	card = devm_kzalloc(dev, sizeof(struct snd_soc_card), GFP_KERNEL);
-	if (!card) {
-		dev_err(dev, "Can't allocate snd_soc_card\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	snd_soc_card_set_drvdata(card, p_aml_audio);
-	card->dev = dev;
-	ret = snd_soc_of_parse_card_name(card, "aml_sound_card,name");
-	if (ret < 0) {
-		dev_err(dev, "no specific snd_soc_card name\n");
-		goto err;
-	}
-
-	ret = aml_card_dais_parse_of(card);
-	if (ret < 0) {
-		dev_err(dev, "parse aml sound card routing error %d\n",
-			ret);
-		goto err;
-	}
-
-	card->suspend_pre = aml_suspend_pre,
-	card->suspend_post = aml_suspend_post,
-	card->resume_pre = aml_resume_pre,
-	card->resume_post = aml_resume_post,
-	ret = devm_snd_soc_register_card(&pdev->dev, card);
-	if (ret < 0) {
-		dev_err(dev, "register aml sound card error %d\n", ret);
-		goto err;
-	}
-
-	aml_i2s_pinmux_init(card);
-	return 0;
- err:
-	dev_err(dev, "Can't probe snd_soc_card\n");
-	return ret;
-}
-
-static const struct of_device_id odroid_dac_of_match[] = {
-	{.compatible = "sound_card, odroid_dac",},
-	{},
-};
-
-static struct platform_driver odroid_dac_audio_driver = {
-	.driver = {
-		   .name = DRV_NAME,
-		   .owner = THIS_MODULE,
-		   .of_match_table = odroid_dac_of_match,
-		   },
-	.probe = odroid_dac_probe,
-};
-
-static int __init odroid_audio_init(void)
-{
-	return platform_driver_register(&odroid_dac_audio_driver);
-}
-
-static void __exit odroid_audio_exit(void)
-{
-	platform_driver_unregister(&odroid_dac_audio_driver);
-}
-
-#ifdef CONFIG_DEFERRED_MODULE_INIT
-deferred_module_init(odroid_audio_init);
-#else
-module_init(odroid_audio_init);
-#endif
-module_exit(odroid_audio_exit);
-
-MODULE_AUTHOR("Hardkernel, Inc.");
-MODULE_DESCRIPTION("ODROID audio machine Asoc driver");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/aml/m8/odroid_hdmi.c b/sound/soc/aml/m8/odroid_hdmi.c
deleted file mode 100644
index bfa83ec..0000000
--- a/sound/soc/aml/m8/odroid_hdmi.c
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- * sound/soc/aml/m8/aml_m8.c
- *
- * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
-*/
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/timer.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
-
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-/* #include <sound/soc-dapm.h> */
-#include <sound/jack.h>
-#include <linux/switch.h>
-/* #include <linux/amlogic/saradc.h> */
-#include <linux/amlogic/iomap.h>
-
-/* #include "aml_i2s_dai.h" */
-#include "aml_i2s.h"
-#include "odroid_hdmi.h"
-#include "aml_audio_hw.h"
-#include <linux/amlogic/sound/audin_regs.h>
-#include <linux/of.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/of_gpio.h>
-#include <linux/io.h>
-#define DRV_NAME "odroid_hdmi_snd"
-/* extern struct device *spdif_dev; */
-
-static int aml_suspend_pre(struct snd_soc_card *card)
-{
-	pr_info(KERN_INFO "enter %s\n", __func__);
-	return 0;
-}
-
-static int aml_suspend_post(struct snd_soc_card *card)
-{
-	pr_info(KERN_INFO "enter %s\n", __func__);
-	return 0;
-}
-
-static int aml_resume_pre(struct snd_soc_card *card)
-{
-	pr_info(KERN_INFO "enter %s\n", __func__);
-	return 0;
-}
-
-static int aml_resume_post(struct snd_soc_card *card)
-{
-	pr_info(KERN_INFO "enter %s\n", __func__);
-	return 0;
-}
-
-static int aml_card_dai_parse_of(struct device *dev,
-				 struct snd_soc_dai_link *dai_link,
-				 int (*init)(struct snd_soc_pcm_runtime *rtd),
-				 struct device_node *cpu_node,
-				 struct device_node *codec_node,
-				 struct device_node *plat_node)
-{
-	int ret;
-
-	/* get cpu dai->name */
-	ret = snd_soc_of_get_dai_name(cpu_node, &dai_link->cpu_dai_name);
-	if (ret < 0)
-		goto parse_error;
-
-	/* get codec dai->name */
-	ret = snd_soc_of_get_dai_name(codec_node, &dai_link->codec_dai_name);
-	if (ret < 0)
-		goto parse_error;
-
-	dai_link->name = dai_link->stream_name = dai_link->cpu_dai_name;
-	dai_link->codec_of_node = of_parse_phandle(codec_node, "sound-dai", 0);
-	dai_link->platform_of_node = plat_node;
-	dai_link->init = init;
-
-	return 0;
-
- parse_error:
-	return ret;
-}
-
-static int aml_card_dais_parse_of(struct snd_soc_card *card)
-{
-	struct device_node *np = card->dev->of_node;
-	struct device_node *cpu_node, *codec_node, *plat_node;
-	struct device *dev = card->dev;
-	struct snd_soc_dai_link *dai_links;
-	int num_dai_links, cpu_num, codec_num, plat_num;
-	int i, ret;
-	int (*init)(struct snd_soc_pcm_runtime *rtd);
-
-	ret = of_count_phandle_with_args(np, "cpu_list", NULL);
-	if (ret < 0) {
-		dev_err(dev, "AML sound card no cpu_list errno: %d\n", ret);
-		goto err;
-	} else {
-		cpu_num = ret;
-	}
-	ret = of_count_phandle_with_args(np, "codec_list", NULL);
-	if (ret < 0) {
-		dev_err(dev, "AML sound card no codec_list errno: %d\n", ret);
-		goto err;
-	} else {
-		codec_num = ret;
-	}
-	ret = of_count_phandle_with_args(np, "plat_list", NULL);
-	if (ret < 0) {
-		dev_err(dev, "AML sound card no plat_list errno: %d\n", ret);
-		goto err;
-	} else {
-		plat_num = ret;
-	}
-	if ((cpu_num == codec_num) && (cpu_num == plat_num)) {
-		num_dai_links = cpu_num;
-	} else {
-		dev_err(dev,
-			"AML sound card cpu_dai num, codec_dai num, platform num don't match: %d\n",
-			ret);
-		ret = -EINVAL;
-		goto err;
-	}
-
-	dai_links =
-	    devm_kzalloc(dev, num_dai_links * sizeof(struct snd_soc_dai_link),
-			 GFP_KERNEL);
-	if (!dai_links) {
-		dev_err(dev, "Can't allocate snd_soc_dai_links\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-	card->dai_link = dai_links;
-	card->num_links = num_dai_links;
-	for (i = 0; i < num_dai_links; i++) {
-		init = NULL;
-		/* CPU sub-node */
-		cpu_node = of_parse_phandle(np, "cpu_list", i);
-		if (cpu_node < 0) {
-			dev_err(dev, "parse aml sound card cpu list error\n");
-			return -EINVAL;
-		}
-		/* CODEC sub-node */
-		codec_node = of_parse_phandle(np, "codec_list", i);
-		if (codec_node < 0) {
-			dev_err(dev, "parse aml sound card codec list error\n");
-			return ret;
-		}
-		/* Platform sub-node */
-		plat_node = of_parse_phandle(np, "plat_list", i);
-		if (plat_node < 0) {
-			dev_err(dev,
-				"parse aml sound card platform list error\n");
-			return ret;
-		}
-
-		ret =
-		    aml_card_dai_parse_of(dev, &dai_links[i], init, cpu_node,
-					  codec_node, plat_node);
-	}
-
- err:
-	return ret;
-}
-
-static int odroid_hdmi_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct snd_soc_card *card;
-	struct hdmi_audio_private_data *p_hdmi_audio;
-	int ret;
-
-	p_hdmi_audio =
-	    devm_kzalloc(dev, sizeof(struct hdmi_audio_private_data),
-			 GFP_KERNEL);
-	if (!p_hdmi_audio) {
-		dev_err(&pdev->dev, "Can't allocate hdmi_audio_private_data\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	card = devm_kzalloc(dev, sizeof(struct snd_soc_card), GFP_KERNEL);
-	if (!card) {
-		dev_err(dev, "Can't allocate snd_soc_card\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	snd_soc_card_set_drvdata(card, p_hdmi_audio);
-	card->dev = dev;
-	ret = snd_soc_of_parse_card_name(card, "aml_sound_card,name");
-	if (ret < 0) {
-		dev_err(dev, "no specific snd_soc_card name\n");
-		goto err;
-	}
-
-	ret = aml_card_dais_parse_of(card);
-	if (ret < 0) {
-		dev_err(dev, "parse aml sound card routing error %d\n",
-			ret);
-		goto err;
-	}
-
-	card->suspend_pre = aml_suspend_pre,
-	card->suspend_post = aml_suspend_post,
-	card->resume_pre = aml_resume_pre,
-	card->resume_post = aml_resume_post,
-	ret = devm_snd_soc_register_card(&pdev->dev, card);
-	if (ret < 0) {
-		dev_err(dev, "register aml sound card error %d\n", ret);
-		goto err;
-	}
-	return 0;
- err:
-	dev_err(dev, "Can't probe snd_soc_card\n");
-	return ret;
-}
-
-static const struct of_device_id odroid_hdmi_of_match[] = {
-	{.compatible = "sound_card, odroid_hdmi",},
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, odroid_hdmi_dt_match);
-
-static struct platform_driver aml_m8_audio_driver = {
-	.driver = {
-		   .name = DRV_NAME,
-		   .owner = THIS_MODULE,
-		   .of_match_table = odroid_hdmi_of_match,
-		   },
-	.probe = odroid_hdmi_probe,
-};
-
-module_platform_driver(aml_m8_audio_driver);
-
-MODULE_AUTHOR("Hardkernel, Inc.");
-MODULE_DESCRIPTION("ODROID audio machine Asoc driver");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/aml/m8/odroid_hdmi.h b/sound/soc/aml/m8/odroid_hdmi.h
deleted file mode 100644
index 7976da0..0000000
--- a/sound/soc/aml/m8/odroid_hdmi.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * sound/soc/aml/m8/aml_m8.h
- *
- * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
-*/
-
-#ifndef AML_M8_H
-#define AML_M8_H
-
-#include <sound/soc.h>
-#include <linux/gpio/consumer.h>
-struct hdmi_audio_private_data {
-	int bias_level;
-	void *data;
-};
-
-void aml_spdif_pinmux_init(struct device *pdev);
-void aml_spdif_pinmux_deinit(struct device *pdev);
-#endif
-
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index e9ab5e1..3216f9b 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -134,7 +134,6 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_WM9713 if SND_SOC_AC97_BUS
 	select SND_SOC_DUMMY_CODEC
 	select SND_SOC_PCM2BT
-	select SND_SOC_PCM5102
         help
           Normally ASoC codec drivers are only built if a machine driver which
           uses them is also built since they are only usable with a machine
@@ -563,6 +562,3 @@ config SND_SOC_DUMMY_CODEC
 
 config SND_SOC_PCM2BT
 	tristate
-
-config SND_SOC_PCM5102
-	tristate
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 9e024d9..f86b42a 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -126,7 +126,6 @@ snd-soc-wm9713-objs := wm9713.o
 snd-soc-wm-hubs-objs := wm_hubs.o
 snd-soc-dummy_codec-objs := dummy_codec.o
 snd-soc-pcm2bt-objs  := pcm2bt.o
-snd-soc-pcm5102-objs := pcm5102.o
 
 # Amp
 snd-soc-max9877-objs := max9877.o
@@ -259,7 +258,6 @@ obj-$(CONFIG_SND_SOC_WM_ADSP)	+= snd-soc-wm-adsp.o
 obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
 obj-$(CONFIG_SND_SOC_DUMMY_CODEC)	+= snd-soc-dummy_codec.o
 obj-$(CONFIG_SND_SOC_PCM2BT)	+= snd-soc-pcm2bt.o
-obj-$(CONFIG_SND_SOC_PCM5102)   += snd-soc-pcm5102.o
 
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
diff --git a/sound/soc/codecs/pcm5102.c b/sound/soc/codecs/pcm5102.c
deleted file mode 100644
index 2935e39..0000000
--- a/sound/soc/codecs/pcm5102.c
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * amlogic ALSA SoC pcm5102 codec driver
- */
-
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <sound/core.h>
-#include <sound/tlv.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/initval.h>
-#include <linux/of.h>
-
-struct pcm5102_private {
-	struct snd_soc_codec codec;
-};
-
-#define PCM5102_RATES		(SNDRV_PCM_RATE_8000_384000)
-#define PCM5102_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
-		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
-
-static int pcm5102_pcm_hw_params(struct snd_pcm_substream *substream,
-				     struct snd_pcm_hw_params *params,
-				     struct snd_soc_dai *dai)
-{
-	return 0;
-}
-
-static int pcm5102_set_dai_fmt(struct snd_soc_dai *codec_dai,
-				   unsigned int fmt)
-{
-	return 0;
-}
-
-static int pcm5102_mute(struct snd_soc_dai *dai, int mute)
-{
-	return 0;
-}
-
-static const struct snd_soc_dapm_widget pcm5102_dapm_widgets[] = {
-	/* Output Side */
-	/* DACs */
-	SND_SOC_DAPM_DAC("Left DAC", "HIFI Playback",
-			 SND_SOC_NOPM, 0, 0),
-	SND_SOC_DAPM_DAC("Right DAC", "HIFI Playback",
-			 SND_SOC_NOPM, 7, 0),
-
-	/* Output Lines */
-	SND_SOC_DAPM_OUTPUT("LOUTL"),
-	SND_SOC_DAPM_OUTPUT("LOUTR"),
-
-};
-
-static const struct snd_soc_dapm_route pcm5102_dapm_routes[] = {
-
-	{"LOUTL", NULL, "Left DAC"},
-	{"LOUTR", NULL, "Right DAC"},
-};
-
-static struct snd_soc_dai_ops pcm5102_ops = {
-	.hw_params = pcm5102_pcm_hw_params,
-	.set_fmt = pcm5102_set_dai_fmt,
-	.digital_mute = pcm5102_mute,
-};
-
-struct snd_soc_dai_driver pcm5102_dai = {
-	.name = "pcm5102",
-	.id = 1,
-	.playback = {
-		     .stream_name = "HIFI Playback",
-		     .channels_min = 2,
-		     .channels_max = 2,
-		     .rates = PCM5102_RATES,
-		     .formats = PCM5102_FORMATS,
-		     },
-	.ops = &pcm5102_ops,
-};
-
-static int pcm5102_probe(struct snd_soc_codec *codec)
-{
-	return 0;
-}
-
-static int pcm5102_remove(struct snd_soc_codec *codec)
-{
-	return 0;
-};
-
-struct snd_soc_codec_driver soc_codec_dev_pcm5102 = {
-	.probe = pcm5102_probe,
-	.remove = pcm5102_remove,
-	.dapm_widgets = pcm5102_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(pcm5102_dapm_widgets),
-	.dapm_routes = pcm5102_dapm_routes,
-	.num_dapm_routes = ARRAY_SIZE(pcm5102_dapm_routes),
-};
-
-#ifdef CONFIG_OF
-static const struct of_device_id amlogic_codec_dt_match[] = {
-	{.compatible = "hardkernel, pcm5102",
-	 },
-	{},
-};
-#else
-#define amlogic_codec_dt_match NULL
-#endif
-
-static int pcm5102_platform_probe(struct platform_device *pdev)
-{
-	struct pcm5102_private *pcm5102;
-	int ret;
-
-	pr_info("pcm5102_platform_probe\n");
-	pcm5102 = kzalloc(sizeof(struct pcm5102_private), GFP_KERNEL);
-	if (pcm5102 == NULL)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, pcm5102);
-	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_pcm5102,
-				     &pcm5102_dai, 1);
-
-	if (ret < 0)
-		kfree(pcm5102);
-
-	return ret;
-}
-
-static int pcm5102_platform_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_codec(&pdev->dev);
-	kfree(platform_get_drvdata(pdev));
-	return 0;
-}
-
-static struct platform_driver pcm5102_platform_driver = {
-	.driver = {
-		   .name = "pcm5102",
-		   .owner = THIS_MODULE,
-		   .of_match_table = amlogic_codec_dt_match,
-		   },
-	.probe = pcm5102_platform_probe,
-	.remove = pcm5102_platform_remove,
-};
-
-static int __init pcm5102_init(void)
-{
-	return platform_driver_register(&pcm5102_platform_driver);
-}
-
-static void __exit pcm5102_exit(void)
-{
-	platform_driver_unregister(&pcm5102_platform_driver);
-}
-
-module_init(pcm5102_init);
-module_exit(pcm5102_exit);
-
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_DESCRIPTION("ASoC pcm5102 driver");
-MODULE_LICENSE("GPL");
-- 
1.9.1

